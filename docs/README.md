# 최종미션

## 개요

코치님들의 점심메뉴를 추천하는 프로그램!

## 기능 구현 목록 정리
1. 프로그램 시작 안내를 출력한다.
2. 코치 이름 입력 안내를 출력한다.
3. 코치 이름을 입력 받는다.
   - 코치 이름 2글자 이상 4글자 이하
   - 코치 이름 중복 안됨
   - 코치 이름 모든 문자 허용 (, 제외)
   - 코치 2명 이상 5명 이하
4. 각 코치마다 못 먹는 메뉴를 입력받는다.
   - 못먹는 메뉴 최소 0개 최대 2개
   - 못 먹는다고 입력한 메뉴가 원래 메뉴에 없는 경우 예외 처리
5. 요일마다 카테고리를 고른다.
   - 각 카테고리가 최대 2번까지만 나와야한다.
6. 각 카테고리에 맞는 메뉴를 추천한다.
   - 각 코치가 못 먹는 메뉴인지 검사한다.
   - 이전에 그 메뉴를 먹었었는지 검사한다.
7. 메뉴 추천 결과를 출력한다.
8. 추천 완료 안내를 출력한다.


## 요구사항

코치들은 월, 화, 수, 목, 금요일에 점심 식사를 같이 한다.
메뉴를 추천하는 과정은 아래와 같이 이뤄진다.
월요일에 추천할 카테고리를 무작위로 정한다.
각 코치가 월요일에 먹을 메뉴를 추천한다.
화, 수, 목, 금요일에 대해 i, ii 과정을 반복한다.
코치의 이름은 최소 2글자, 최대 4글자이다.
코치는 최소 2명, 최대 5명까지 식사를 함께 한다.
각 코치는 최소 0개, 최대 2개의 못 먹는 메뉴가 있다. (, 로 구분해서 입력한다.)
먹지 못하는 메뉴가 없으면 빈 값을 입력한다.
추천을 못하는 경우는 발생하지 않으니 고려하지 않아도 된다.
한 주에 같은 카테고리는 최대 2회까지만 고를 수 있다.
각 코치에게 한 주에 중복되지 않는 메뉴를 추천해야 한다.
예시)
구구: 비빔밥, 김치찌개, 쌈밥, 규동, 우동 → 한식을 3회 먹으므로 불가능
토미: 비빔밥, 비빔밥, 규동, 우동, 볶음면 → 한 코치가 같은 메뉴를 먹으므로 불가능
제임스: 비빔밥, 김치찌개, 스시, 가츠동, 짜장면 → 매일 다른 메뉴를 먹으므로 가능
포코: 비빔밥, 김치찌개, 스시, 가츠동, 짜장면 → 제임스와 메뉴가 같지만, 포코는 매번 다른 메뉴를 먹으므로 가능
메뉴 추천을 완료하면 프로그램이 종료된다.

## 주요 요구 사항

- 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
- Exception이 아닌 IllegalArgumentException, IllegalStateException 등과 같은 명확한 유형을 처리한다.
- 프로그래밍 요구 사항에서 달리 명시하지 않는 한 파일, 패키지 이름을 수정하거나 이동하지 않는다.
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
- 메서드의 파라미터 개수는 최대 3개까지만 허용한다.
- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.

## 체크리스트

[x] 요구사항을 정확히 준수하였는가?</br>
[x] 추가적인 예외를 고려하였는가?</br>
[x] 메소드가 하나의 기능만 하는가?</br>
[△] 한 메소드에 오직 한 단계의 인덴트만 허용했는가? => 두 단계까지</br>
[x] 메소드 15줄 안 넘는가?</br>
[x] else 쓰지 않았는가?</br>
[x] 원시값과 문자열 포장했는가?</br>
[x] 콜렉션에 대해 일급 콜렉션을 적용했는가?</br>
[x] 3개 이상의 인스턴스 변수를 가진 클래스를 구현하지는 않았는가?</br>
[x] 메소드 이름이 적절한가? 동사와 전치사로 시작하는가?</br>
[x] 변수의 이름이 적절한가? 명사인가?</br>
[x] 메소드와 변수의 이름을 축약하지는 않았는가? 중복하지는 않았는가?</br>
[x] 커밋 메시지가 적절한가? 의미는 명확한가?</br>
[x] 매직넘버를 상수로 선언했는가?</br>
[△] getter/setter가 없이 구현했는가? => 최소화하려고 노력했다.</br>
[x] 하나의 소스 파일에 하나의 클래스만 있는가?</br>
[x] 클래스를 작게 유지하기 위해 노력했는가?</br>
[x] import에 와일드 카드(*)가 없는가?</br>
[x] 패키지 선언 후와 메소드들의 사이에 빈 줄을 넣었는가?</br>
[x] 공백도 컨벤션을 준수했는가? 공백 라인을 의미있게 사용했는가?</br>
[x] 의미 없는 주석은 없는가?</br>
[x] Java가 제공하는 API를 적극 활용했는가?</br>
[x] 배열 대신 Java Collection을 사용했는가?</br>
[x] 정리한 기능 목록마다 정상 동작함을 테스트 코드로 확인하였는가?</br>
[x] PR 이름 제대로 했는가?</br>
[x] 출력 형식 제대로 했는가?</br>
[x] 불필요한 멤버 변수는 없는가?</br>
[x] 테스트코드의 리팩터링을 했는가?</br>
[x] 파라미터의 값만 바뀌는 테스트코드에서 @valueSource를 사용했는가?</br>
[x] final 값을 적절히 사용했는가?</br>
[x] 인스턴스 변수의 접근 제한을 private으로 했는가?</br>
[x] 단위테스트하기 어려운 코드를 적절히 리팩터링 했는가?</br>
[x] view가 domain을 모르는가?</br>
[x] domain이 view를 모르는가?</br>
[x] controller가 domain을 모르는가?</br>
[x] view와 domain 사이에 dto만 주고 받는가?</br>
[x] controller와 service가 dto를 통해 값을 주고 받는가?</br>
[x] service가 view를 모르는가?</br>
[x] dto가 service에서 변환되고 있는가? (controllers는 dto를 주고 받는 역할만 하고 있는가?, 즉 서비스 로직이 컨트롤러에 포함되어있지는 않은가?)</br>